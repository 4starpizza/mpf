<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>mpf.system.light_controller module &mdash; Mission Pinball Framework 0.0.7 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '0.0.7',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="Mission Pinball Framework 0.0.7 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">Mission Pinball Framework 0.0.7 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="module-mpf.system.light_controller">
<span id="mpf-system-light-controller-module"></span><h1>mpf.system.light_controller module</h1>
<p>Manages the lighting effects in a pinball machine.</p>
<dl class="class">
<dt id="mpf.system.light_controller.LightController">
<em class="property">class </em><tt class="descclassname">mpf.system.light_controller.</tt><tt class="descname">LightController</tt><big>(</big><em>machine</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Manages all the lights in a pinball machine. Handles updates,
priorities, restores, running and stopping LightShows, etc. There should be
only one per machine.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>machine</strong> &#8211; Parent machine object.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="mpf.system.light_controller.LightController.convert_hex_to_list">
<tt class="descname">convert_hex_to_list</tt><big>(</big><em>inputstring</em><big>)</big></dt>
<dd><p>Takes a string input of hex numbers and returns a list of integers</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>inputstring</strong> (<em>str</em>) &#8211; incoming hex colors, like ffff00.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">List of colors as integers, like [255, 255, 0]</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.disable">
<tt class="descname">disable</tt><big>(</big><em>lightname</em>, <em>priority=0</em>, <em>clear_all=True</em><big>)</big></dt>
<dd><p>Command to disable an light</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lightname</strong> (<em>str</em>) &#8211; The name of the light you&#8217;re disabling</li>
<li><strong>priority</strong> (<em>int</em>) &#8211; Which priority you&#8217;re clearing (disabling) the
light at. (See <em>clear_all</em> below for details.) If you don&#8217;t
pass a priority, then it will disable the light and remove
<em>all</em> entries from the manual commands list. i.e. In that case
it disables/removes all the previously issued manual commands</li>
<li><strong>clear_all</strong> (<em>bool</em>) &#8211; If True, it will clear all the commands from the
priority you passed and from any lower priority commands. If
False then it only clears out the command from the priority
that was passed.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Once cleared, <a class="reference internal" href="#mpf.system.light_controller.LightController" title="mpf.system.light_controller.LightController"><tt class="xref py py-class docutils literal"><span class="pre">LightController</span></tt></a> restore the light&#8217;s state from
any commands or shows running at a lower priority.</p>
<p>Note that this method does not affect running <a class="reference internal" href="#mpf.system.light_controller.LightShow" title="mpf.system.light_controller.LightShow"><tt class="xref py py-class docutils literal"><span class="pre">LightShow</span></tt></a> shows,
so if you clear the <a class="reference internal" href="#mpf.system.light_controller.LightController.enable" title="mpf.system.light_controller.LightController.enable"><tt class="xref py py-meth docutils literal"><span class="pre">enable()</span></tt></a> commands but you have a running
LightShow which enables that light, then the light will be enablight.
If you want to absolutely disable the light regardless of whatever
LightShow is running, then use <a class="reference internal" href="#mpf.system.light_controller.LightController.enable" title="mpf.system.light_controller.LightController.enable"><tt class="xref py py-meth docutils literal"><span class="pre">enable()</span></tt></a> with <em>color=000000</em>,
<em>blend=False</em>, and a <em>priority</em> that&#8217;s higher than any running show.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.enable">
<tt class="descname">enable</tt><big>(</big><em>lightname</em>, <em>priority=0</em>, <em>color=None</em>, <em>dest_color=None</em>, <em>fade=0</em>, <em>blend=True</em><big>)</big></dt>
<dd><p>This is a single one-time command to enable an light.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lightname</strong> &#8211; the light you&#8217;re enabling</li>
<li><strong>priority</strong> (<em>int</em>) &#8211; The priority this light will be enablight at. This
is used when determining what other enables, scripts, and
LightShows will play over or under it). If you enable an light
with the same priority that was previously used to enable it,
it will overwrite the old color with the new one.</li>
<li><strong>color</strong> (<em>str</em>) &#8211; A hex string (like &#8220;ff00aa&#8221;) for what color you want to
enable this light to be. Note if you have a single color (i.e.
one element) light, then just pass it &#8220;ff&#8221; to enable it on full
brightness, or &#8220;80&#8221; for 50%, etc.</li>
<li><strong>dest_color</strong> (<em>str</em>) &#8211; If you want to fade the light to your color instead
of enabling it instantly, pass <em>dest_color</em> instead of <em>color</em>.</li>
<li><strong>fade</strong> (<em>int</em>) &#8211; If you want to fade the light on, use <em>fade</em> to specify the
fade on time (in ms). Note this also requires <em>dest_color</em>
above instead of <em>color</em>.</li>
<li><strong>blend</strong> (<em>bool</em>) &#8211; If <em>True</em> and if you&#8217;re using a fade, it will fade
from whatever color the light currently is to your
<em>dest_color</em>. If False it will turn the light off first before
fading.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Note that since you enable lights with priorities, you can actually
&#8220;enable&#8221; the light multiple times at different priorties. Then if you
disable the light via a higher priority, the lower priority will still
be there. This means that in your game, each mode can do whatever it
wants with lights and you don&#8217;t have to worry about a higher priority
mode clearing out an light and messing up the lower priority mode&#8217;s
status.</p>
<p>The ability for this enable method to also keep track of the priority
that a light is enablight is the reason you&#8217;d want to use this method
versus calling <tt class="xref py py-meth docutils literal"><span class="pre">lights.color()</span></tt> directly. If you do use
<tt class="xref py py-meth docutils literal"><span class="pre">lights.color()</span></tt> to enable an light directly,
<a class="reference internal" href="#mpf.system.light_controller.LightController" title="mpf.system.light_controller.LightController"><tt class="xref py py-class docutils literal"><span class="pre">LightController</span></tt></a> won&#8217;t know about it, and your light could be
overwritten the next time a LightShow, script, or enable command is
used.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.get_light_state">
<tt class="descname">get_light_state</tt><big>(</big><em>lightname</em>, <em>priority=0</em><big>)</big></dt>
<dd><p>Looks at all the active shows and returns the current
details for a given light.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lightname</strong> (<em>string</em>) &#8211; The light we&#8217;re looking for</li>
<li><strong>priority</strong> (<em>integer</em>) &#8211; Returns the color from the highest priority</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>lower than the priority passed it.</p>
<dl class="docutils">
<dt>Returns tuple of:</dt>
<dd>&#8216;color&#8217;: The restored color for the light.
&#8216;priority&#8217;: The priority of that light.
&#8216;blend&#8217;: If the light we&#8217;re restoring is blending below itself.
&#8216;fadeend&#8217;: (optional) If there&#8217;s a fade, what fade time should be
used.
&#8216;dest_color&#8217;: (optional) If there&#8217;s a fade, what fade color
should be used.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.get_midfade_color">
<tt class="descname">get_midfade_color</tt><big>(</big><em>fadestart</em>, <em>fadeend</em>, <em>midpoint_time</em>, <em>orig_color</em>, <em>dest_color</em><big>)</big></dt>
<dd><p>Figures out the new fade values based on a current fade in progress.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>fadestart</strong> &#8211; The realtime time that this fade begin.</li>
<li><strong>fadeend</strong> &#8211; The realtime time that this fade ends.</li>
<li><strong>midpoint_time</strong> &#8211; The current time &#8220;mid point&#8221; that we&#8217;re using for
our new fade.</li>
<li><strong>orig_color</strong> &#8211; The original color in hex.</li>
<li><strong>dest_color</strong> &#8211; the final destination color in hex.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">&#8216;color&#8217;: The current color we need to reset the light to in hex</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.restore_light_state">
<tt class="descname">restore_light_state</tt><big>(</big><em>lightname</em>, <em>priority=None</em>, <em>fadeend=None</em>, <em>color=None</em><big>)</big></dt>
<dd><p>Restores a light to whatever state it should be in below the passed
priority parameter. Similar to <a class="reference internal" href="#mpf.system.light_controller.LightController.get_light_state" title="mpf.system.light_controller.LightController.get_light_state"><tt class="xref py py-meth docutils literal"><span class="pre">get_light_state()</span></tt></a> except it
actually makes the change rather than only returning values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>lightname</strong> (<em>str</em>) &#8211; The name of the light we want to restore</li>
<li><strong>priority</strong> (<em>int</em>) &#8211; We will only restore the light to a priority
lower than this.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Optional parameters which are used if our current light is fading to
off and we need to blend it with whatever is below it :param string
fadeend: Realtime of when the fade will end :param string color: The
current hex color of the light.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.run_script">
<tt class="descname">run_script</tt><big>(</big><em>lightname</em>, <em>script</em>, <em>priority=0</em>, <em>repeat=True</em>, <em>blend=False</em>, <em>tps=1000</em>, <em>num_repeats=0</em>, <em>callback=None</em><big>)</big></dt>
<dd><p>Runs a light script. Scripts are similar to LightShows, except they
only apply to single lights and you can &#8220;attach&#8221; any script to any
light. Scripts are used anytime you want an light to have more than one
action. A simple example would be a flash an light. You would make a
script that turned it on (with your color), then off, repeating
forever.</p>
<p>Scripts could be more complex, like cycling through multiple colors,
blinking out secret messages in Morse code, etc.</p>
<p>Interally we actually just take a script and dynamically convert it
into a LightShow (that just happens to only be for a single light), so
we can have all the other LightShow-like features, including playback
speed, repeats, blends, callbacks, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>lightname</strong> &#8211; The name of the light for this script to control.</li>
<li><strong>script</strong> &#8211; A list of dictionaries of script commands. (See below)
priority&#8217;: The priority the light in this script should operate
at.</li>
<li><strong>repeat</strong> (<em>bool</em>) &#8211; Whether the script repeats (loops).</li>
<li><strong>blend</strong> (<em>bool</em>) &#8211; Whether the script should blend the light colors with
lower prioirty things. todo</li>
<li><strong>tps</strong> (<em>int</em>) &#8211; Tocks per second. todo</li>
<li><strong>num_repeats</strong> (<em>int</em>) &#8211; How many times this script should repeat before
ending. A value of 0 indicates it will repeat forever. Also
requires <em>repeat=True</em>. &#8216;callback&#8217;: A callback function that is
called when the script is stopped. todo update</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><a class="reference internal" href="#mpf.system.light_controller.LightShow" title="mpf.system.light_controller.LightShow"><tt class="xref py py-class docutils literal"><span class="pre">LightShow</span></tt></a> object. Since running a script just sets up and
runs a regular LightShow, run_script returns the LightShow object.
In most cases you won&#8217;t need this, but it&#8217;s nice if you want to
know exactly which LightShow was created by this script so you can
stop it later. (See the examples below for usage.)</p>
</td>
</tr>
</tbody>
</table>
<p>The script is a list of dictionaries, with each list item being a
sequential instruction, and the dictionary defining what you want to
do at that step. Dictionary items for each step are:</p>
<blockquote>
<div><p>color: The hex color for the light
time: How long (in ms) you want the light to be at that color
fade: True/False. Whether you want that light to fade to the color</p>
<blockquote>
<div>(using the <em>time</em> above), or whether you want it to switch to
that color instantly.</div></blockquote>
</div></blockquote>
<p>Example usage:</p>
<p>Here&#8217;s how you would use the script to flash an RGB light between red
and off:</p>
<blockquote>
<div><p>self.flash_red = []
self.flash_red.append({&#8220;color&#8221;: &#8220;ff0000&#8221;, &#8220;time&#8221;: 100})
self.flash_red.append({&#8220;color&#8221;: &#8220;000000&#8221;, &#8220;time&#8221;: 100})
self.machine.light_controller.run_script(&#8220;light1&#8221;, self.flash_red,</p>
<blockquote>
<div>&#8220;4&#8221;, blend=True)</div></blockquote>
</div></blockquote>
<p>Once the &#8220;flash_red&#8221; script is defined as self.flash_red, you can use
it anytime for any light. So if you want to flash two lights red, it
would be:</p>
<blockquote>
<div><dl class="docutils">
<dt>self.machine.light_controller.run_script(&#8220;light1&#8221;, self.flash_red,</dt>
<dd>&#8220;4&#8221;, blend=True)</dd>
<dt>self.machine.light_controller.run_script(&#8220;light2&#8221;, self.flash_red,</dt>
<dd>&#8220;4&#8221;, blend=True)</dd>
</dl>
</div></blockquote>
<p>Most likely you would define your scripts once when the game loads and
then call them as needed.</p>
<p>You can also make more complex scripts. For example, here&#8217;s a script
which smoothly cycles an RGB light through all colors of the rainbow:</p>
<blockquote>
<div>self.rainbow = []
self.rainbow.append({&#8216;color&#8217;: &#8216;ff0000&#8217;, &#8216;time&#8217;: 400, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;ff7700&#8217;, &#8216;time&#8217;: 400, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;ffcc00&#8217;, &#8216;time&#8217;: 400, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;00ff00&#8217;, &#8216;time&#8217;: 400, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;0000ff&#8217;, &#8216;time&#8217;: 400, &#8216;fade&#8217;: True})
self.rainbow.append({&#8216;color&#8217;: &#8216;ff00ff&#8217;, &#8216;time&#8217;: 400, &#8216;fade&#8217;: True})</div></blockquote>
<p>If you have single color lights, your <em>color</em> entries in your script
would only contain a single hex value for the intensity of that light.
For example, a script to flash a single-color light on-and-off (which
you can apply to any light):</p>
<blockquote>
<div>self.flash = []
self.flash.append({&#8220;color&#8221;: &#8220;ff&#8221;, &#8220;time&#8221;: 100})
self.flash.append({&#8220;color&#8221;: &#8220;00&#8221;, &#8220;time&#8221;: 100})</div></blockquote>
<p>If you&#8217;d like to save a reference to the <a class="reference internal" href="#mpf.system.light_controller.LightShow" title="mpf.system.light_controller.LightShow"><tt class="xref py py-class docutils literal"><span class="pre">LightShow</span></tt></a> that&#8217;s
created by this script, call it like this:</p>
<blockquote>
<div><dl class="docutils">
<dt>self.blah = self.machine.light_controller.run_script(&#8220;light2&#8221;,</dt>
<dd>self.flash_red, &#8220;4&#8221;)</dd>
</dl>
</div></blockquote>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightController.stop_script">
<tt class="descname">stop_script</tt><big>(</big><em>lightname=None</em>, <em>priority=0</em>, <em>show=None</em><big>)</big></dt>
<dd><p>Stops and remove an light script.</p>
<p>Rarameters:</p>
<blockquote>
<div>&#8216;lightname&#8217;: The light(s) with the script you want to stop.
&#8216;priority&#8217;: The priority of the script(s) you want to stop.
&#8216;show&#8217;: The show object associated with a script you want to stop.</div></blockquote>
<p>In a practical sense there are several ways you can use this
stop_script method:</p>
<blockquote>
<div><ul class="simple">
<li>Specify <em>lightname</em> only to stop (and remove) all active
LightShows created from scripts for that lightname, regardless of
priority.</li>
<li>Specify <em>priority</em> only to stop (and remove) all active
LightShows based on scripts running at that priority for all
lights.</li>
<li>Specify <em>lightname</em> and <em>priority</em> to stop (and remove) all
active LightShows for that lightname at the specific priority you
passed.</li>
<li>Specify a <em>show</em> object to stop and remove that specific show.</li>
<li>If you call stop_script() without passing it anything, it will</li>
</ul>
<p>remove all the lightsshows started from all scripts. This is useful
for things like end of ball or tilt where you just want to kill
everything.</p>
</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpf.system.light_controller.LightShow">
<em class="property">class </em><tt class="descclassname">mpf.system.light_controller.</tt><tt class="descname">LightShow</tt><big>(</big><em>machine</em>, <em>filename=None</em>, <em>actions=None</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Represents a LightShow which is a sequential list of lights, colors, and
timings that can be played back. Individual shows can be started, stopped,
reset, etc. Shows can be played at any speed, sped up, slowed down, etc.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>machine</strong> (<em>obj</em>) &#8211; Parent machine object.</li>
<li><strong>filename</strong> (<em>str</em>) &#8211; File (and path) of the LightShow yaml file</li>
<li><strong>actions</strong> (<em>list</em>) &#8211; List of LightShow actions which are passed directly
instead of read from a yaml file</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>If you pass <em>filename</em>, it will process the actions based on that file.
Otherwise it will look for the actions from the list passed via <em>actions</em>.
Either <em>filename</em> or <em>actions</em> is required.</p>
<dl class="method">
<dt id="mpf.system.light_controller.LightShow.change_speed">
<tt class="descname">change_speed</tt><big>(</big><em>tocks_per_sec=1</em><big>)</big></dt>
<dd><p>Changes the playback speed of a running LightShow.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tocks_per_sec</strong> (<em>integer</em>) &#8211; The new tocks_per_second play rate.</td>
</tr>
</tbody>
</table>
<p>If you want to change the playback speed by a percentage, you can
access the current tocks_per_second rate via LightShow&#8217;s
tocks_per_second variable. So if you want to double the playback speed
of your show, you could do something like:</p>
<blockquote>
<div>self.your_show.change_speed(self.your_show.tocks_per_second*2)</div></blockquote>
<p>Note that you can&#8217;t just update the show&#8217;s tocks_per_second directly
because we also need to update self.secs_per_tock.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightShow.play">
<tt class="descname">play</tt><big>(</big><em>repeat=False</em>, <em>priority=0</em>, <em>blend=False</em>, <em>hold=False</em>, <em>tocks_per_sec=32</em>, <em>start_location=-1</em>, <em>callback=None</em>, <em>num_repeats=0</em><big>)</big></dt>
<dd><p>Plays a LightShow. There are many parameters you can use here which
affect how the show is played. This includes things like the playback
speed, priority, whether this show blends with others, etc. These are
all set when the show plays. (For example, you could have a LightShow
file which lights a bunch of lights sequentially in a circle pattern,
but you can have that circle &#8220;spin&#8221; as fast as you want depending on
how you play the show.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>repeat</strong> (<em>boolean</em>) &#8211; True/False, whether the show repeats when it&#8217;s</td>
</tr>
</tbody>
</table>
<p>done.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>priority</strong> (<em>integer</em>) &#8211; The relative priority of this show. If there&#8217;s</td>
</tr>
</tbody>
</table>
<p>ever a situation where multiple shows (or light commands) want to
control the same light, the one with the higher priority will win.
(&#8220;Higher&#8221; means a bigger number, so a show with priority 2 will
override a priority 1.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blend</strong> (<em>boolean</em>) &#8211; Controls whether this show &#8220;blends&#8221; with lower</td>
</tr>
</tbody>
</table>
<p>priority shows and scripts. For example, if this show turns a light
off, but a lower priority show has that light set to blue, then the
light will &#8220;show through&#8221; as blue while it&#8217;s off here. If you don&#8217;t
want that behavior, set blend to be False. Then off here will be off
for sure (unless there&#8217;s a higher priority show or command that turns
the light on).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hold</strong> (<em>boolean</em>) &#8211; If True, then when this LightShow ends, all the</td>
</tr>
</tbody>
</table>
<p>lights that are on at that time will remain on. If False, it turns them
all off when the show ends</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tocks_per_sec</strong> (<em>integer</em>) &#8211; This is how fast your show runs.</td>
</tr>
</tbody>
</table>
<p>(&#8220;Playback speed,&#8221; in other words. Your LightShow files specify action
times in terms of &#8216;tocks&#8217;, like &#8220;make this light red for 3 tocks, then
off for 4 tocks, then a different light on for 6 tocks. When you play a
show, you specify how many tocks per second you want it to play.
Default is 32, but you might even want tocks_per_sec of only 1 or 2 if
your show doesn&#8217;t need to move than fast. Note this does not affect
fade rates. So you can have tocks_per_sec of 1 but still have lights
fade on and off at whatever rate you want. Also the term &#8220;tocks&#8221; was
chosen so as not to confuse it with &#8220;ticks&#8221; which is used by the
machine loop.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>start_location</strong> (<em>integer</em>) &#8211; Which position in the show file the show</td>
</tr>
</tbody>
</table>
<p>should start in. Usually this is 0 but it&#8217;s nice to start part way
through. Also used for restarting shows that you paused.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>callback</strong> (<em>object</em>) &#8211; A callback function that is invoked when the</td>
</tr>
</tbody>
</table>
<p>show is stopped.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>num_repeats</strong> (<em>integer</em>) &#8211; How many times you want this show to repeat</td>
</tr>
</tbody>
</table>
<p>before stopping. A value of 0 means that it repeats indefinitely. Note
this only works if you also have repeat=True.</p>
<p>Example usage from a game mode:</p>
<dl class="docutils">
<dt>Load the show (typically done once when the machine is booting up)</dt>
<dd>self.show1 = lights.LightShow(self.machine,
&#8220;LightShowsshow1.yaml&#8221;)</dd>
<dt>Play the show:</dt>
<dd>self.show1.play(repeat=True, tocks_per_sec=10, priority=3)</dd>
<dt>Stop the show:</dt>
<dd>self.show1.stop()</dd>
<dt>Play the show again, but twice as fast as before</dt>
<dd>self.show1.play(repeat=True, tocks_per_sec=20, priority=3)</dd>
<dt>Play the show so it only repeats twice and then stops itself</dt>
<dd><dl class="first last docutils">
<dt>self.show1.play(repeat=True, tocks_per_sec=20, priority=3,</dt>
<dd>num_repeats=True)</dd>
</dl>
</dd>
<dt>Play two shows at once:</dt>
<dd>self.show1.play(repeat=True, tocks_per_sec=20, priority=3)
self.show2.play(repeat=True, tocks_per_sec=5, priority=3)</dd>
</dl>
<p>Play two shows at once, but have one be a higher priority meaning it
will &#8220;win&#8221; if both shows want to control the same light at the same
time:</p>
<blockquote>
<div>self.show1.play(repeat=True, tocks_per_sec=20, priority=4)
self.show2.play(repeat=True, tocks_per_sec=5, priority=3)</div></blockquote>
<p>etc.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.LightShow.stop">
<tt class="descname">stop</tt><big>(</big><em>reset=True</em>, <em>hold=False</em><big>)</big></dt>
<dd><p>Stops a LightShow.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reset</strong> (<em>boolean</em>) &#8211; True means it resets the show to the beginning.</td>
</tr>
</tbody>
</table>
<p>False it keeps it where it is so the show can pick up where it left off</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hold</strong> (<em>boolean</em>) &#8211; Lets you specify that the lights will be held in</td>
</tr>
</tbody>
</table>
<p>their current state after the show ends. Note that if you have a show
that&#8217;s set to hold but you pass hold=False here, it won&#8217;t work. In that
case you&#8217;d have to set &lt;show&gt;.hold=False and then call this method to
stop the show.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="mpf.system.light_controller.Playlist">
<em class="property">class </em><tt class="descclassname">mpf.system.light_controller.</tt><tt class="descname">Playlist</tt><big>(</big><em>machine</em><big>)</big></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>A list of <a class="reference internal" href="#mpf.system.light_controller.LightShow" title="mpf.system.light_controller.LightShow"><tt class="xref py py-class docutils literal"><span class="pre">LightShow</span></tt></a> objects which are then played sequentially.
Playlists are useful for things like attract mode where you play one show
for a few seconds, then another, etc.</p>
<p>Each step in a playlist can contain more than one <a class="reference internal" href="#mpf.system.light_controller.LightShow" title="mpf.system.light_controller.LightShow"><tt class="xref py py-class docutils literal"><span class="pre">LightShow</span></tt></a>. This
is useful if you have a lot of little shows for different areas of the
playfield that you want run at the same time. For example, you might have
one show that only controls a group of rollover lane lights, and another
which blinks the lights in the center of the playfield. You can run them at
the by putting them in the same step in your playlist. (Note you don&#8217;t need
to use a playlist if you simply want to run two LightShows at the same
time. In that case you could just call <a class="reference internal" href="#mpf.system.light_controller.LightShow.play" title="mpf.system.light_controller.LightShow.play"><tt class="xref py py-meth docutils literal"><span class="pre">LightShow.play()</span></tt></a> twice to play
both shows.</p>
<p>For each &#8220;step&#8221; in the playlist, you can specify the number of seconds it
runs those shows before moving on, or you can specify that one of the shows
in that step plays a certain number of times and then the playlist moves
to the next step from there.</p>
<p>You create a show by creating an instance <a class="reference internal" href="#mpf.system.light_controller.Playlist" title="mpf.system.light_controller.Playlist"><tt class="xref py py-class docutils literal"><span class="pre">Playlist</span></tt></a>. Then you
add LightShows to it via <a class="reference internal" href="#mpf.system.light_controller.Playlist.add_show" title="mpf.system.light_controller.Playlist.add_show"><tt class="xref py py-meth docutils literal"><span class="pre">add_show()</span></tt></a>. Finally, you specify the
settings for each step (like how it knows when to move on) via :meth:
<cite>step_settings</cite>.</p>
<p>When you start a playlist (via <a class="reference internal" href="#mpf.system.light_controller.Playlist.start" title="mpf.system.light_controller.Playlist.start"><tt class="xref py py-meth docutils literal"><span class="pre">start()</span></tt></a>, you can specify
settings like what priority the show runs at, whether it repeats, etc.)</p>
<p>Example usage from a game mode:
(This example assumes we have self.show1, self.show2, and self.show3
already loaded.)</p>
<p>Setup the playlist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span> <span class="o">=</span> <span class="n">lights</span><span class="o">.</span><span class="n">Playlist</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">machine</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">add_show</span><span class="p">(</span><span class="n">step_num</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show1</span><span class="p">,</span> <span class="n">tocks_per_sec</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">add_show</span><span class="p">(</span><span class="n">step_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show2</span><span class="p">,</span> <span class="n">tocks_per_sec</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">add_show</span><span class="p">(</span><span class="n">step_num</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">show3</span><span class="p">,</span> <span class="n">tocks_per_sec</span><span class="o">=</span><span class="mi">32</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">step_settings</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">step_settings</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">step_settings</span><span class="p">(</span><span class="n">step</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Run the playlist:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="bp">self</span><span class="o">.</span><span class="n">my_playlist</span><span class="o">.</span><span class="n">start</span><span class="p">(</span><span class="n">priority</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">repeat</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Stop the playlist:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">self.my_playlist.stop()</span></tt></div></blockquote>
<dl class="method">
<dt id="mpf.system.light_controller.Playlist.add_show">
<tt class="descname">add_show</tt><big>(</big><em>step_num</em>, <em>show</em>, <em>num_repeats=0</em>, <em>tocks_per_sec=32</em>, <em>blend=False</em>, <em>repeat=True</em><big>)</big></dt>
<dd><p>Adds a LightShow to this playlist. You have to add at least one show
before you start playing the playlist.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>step_num</strong> (<em>integer</em>) &#8211; </td>
</tr>
</tbody>
</table>
<p>Which step number you&#8217;re adding this show to.
You have to specify this since it&#8217;s possible to add multiple shows to
the same step (in cases where you want them both to play at the same
time during that step). If you want the same show to play in multiple
steps, then add it multiple times (once to each step). The show plays
starting with the lowest number step and then moving on. Ideally they&#8217;d
be 1, 2, 3... but it doesn&#8217;t matter. If you have step numbers of 1, 2,
5... then the player will figure it out.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>show</strong> (<em>object</em>) &#8211; The LightShow object that you&#8217;re adding to this</td>
</tr>
</tbody>
</table>
<p>step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>num_repeats</strong> (<em>integer</em>) &#8211; How many times you want this show to repeat</td>
</tr>
</tbody>
</table>
<p>within this step. Note this does not affect when the playlist advances
to the next step. (That is controlled via <a class="reference internal" href="#mpf.system.light_controller.Playlist.step_settings" title="mpf.system.light_controller.Playlist.step_settings"><tt class="xref py py-meth docutils literal"><span class="pre">step_settings()</span></tt></a>.)
Rather, this is just how many loops this show plays. A value of 0
means it repeats indefinitely. (Well, until the playlist advances to
the next step.) Note that you also have to have repeat=True for it to
repeat here.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tocks_per_sec</strong> (<em>integer</em>) &#8211; How fast you want this show to play. See</td>
</tr>
</tbody>
</table>
<p><a class="reference internal" href="#mpf.system.light_controller.LightShow.play" title="mpf.system.light_controller.LightShow.play"><tt class="xref py py-meth docutils literal"><span class="pre">LightShow.play()</span></tt></a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>blend</strong> (<em>boolean</em>) &#8211; Whether you want this show to blend with lower</td>
</tr>
</tbody>
</table>
<p>priority shows below it. See <a class="reference internal" href="#mpf.system.light_controller.LightShow.play" title="mpf.system.light_controller.LightShow.play"><tt class="xref py py-meth docutils literal"><span class="pre">LightShow.play()</span></tt></a> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>repeat</strong> (<em>boolean</em>) &#8211; Causes the show to keep repeating until the</td>
</tr>
</tbody>
</table>
<p>playlist moves on to the next step.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Playlist.start">
<tt class="descname">start</tt><big>(</big><em>priority</em>, <em>repeat=True</em>, <em>repeat_count=0</em>, <em>reset=True</em><big>)</big></dt>
<dd><p>Starts playing a playlist. You can only use this after you&#8217;ve added
at least one show via <a class="reference internal" href="#mpf.system.light_controller.Playlist.add_show" title="mpf.system.light_controller.Playlist.add_show"><tt class="xref py py-meth docutils literal"><span class="pre">add_show()</span></tt></a> and configured the settings for
each step via <a class="reference internal" href="#mpf.system.light_controller.Playlist.step_settings" title="mpf.system.light_controller.Playlist.step_settings"><tt class="xref py py-meth docutils literal"><span class="pre">step_settings()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>priority</strong> (<em>integer</em>) &#8211; What priority you want the <a class="reference internal" href="#mpf.system.light_controller.LightShow" title="mpf.system.light_controller.LightShow"><tt class="xref py py-class docutils literal"><span class="pre">LightShow</span></tt></a></td>
</tr>
</tbody>
</table>
<p>shows in this playlist to play at. These shows will play &#8220;on top&#8221; of
lower priority stuff, but &#8220;under&#8221; higher priority things.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>repeat</strong> (<em>boolean</em>) &#8211; <ul class="simple">
<li>Controls whether this playlist to repeats when</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>it&#8217;s finished.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>repeat_count</strong> (<em>integer</em>) &#8211; How many times you want this playlist to</td>
</tr>
</tbody>
</table>
<p>repeat before it stops itself. (Must be used with <em>repeat=True</em> above.)
A value of 0 here means that this playlist repeats forever until you
manually stop it. (This is ideal for attract mode.)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reset</strong> (<em>boolean</em>) &#8211; <ul class="simple">
<li>Controls whether you want this playlist to</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>start at the begining (True) or you want it to pick up where it left
off (False). You can also use <em>reset</em> to restart a playlist that&#8217;s
currently running.</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Playlist.step_settings">
<tt class="descname">step_settings</tt><big>(</big><em>step</em>, <em>time=0</em>, <em>trigger_show=None</em><big>)</big></dt>
<dd><p>Used to configure the settings for a step in a <a class="reference internal" href="#mpf.system.light_controller.Playlist" title="mpf.system.light_controller.Playlist"><tt class="xref py py-class docutils literal"><span class="pre">Playlist</span></tt></a>.
This configuration is required for each step. The main thing you use
this for is to specify how the playlist knows to move on to the next
step.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>step</strong> (<em>integer</em>) &#8211; Which step number you&#8217;re configuring</li>
<li><strong>time</strong> (<em>float</em>) &#8211; The time in seconds that you want this step to run</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>before moving on to the next one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trigger_show</strong> (<em>object</em>) &#8211; If you want to move to the next step after</td>
</tr>
</tbody>
</table>
<p>one of the LightShows in this step is done playing, specify that
LightShow here. This is required because if there are multiple
LightShows in this step of the playlist which all end at different
times, we wouldn&#8217;t know which one to watch in order to know when to
move on.</p>
<p>Note that you can have repeats with a trigger show, but in that case
you also need to have the num_repeats specified. Otherwise if you have
your trigger show repeating forever then the playlist will never move
on. (In that case use the <em>time</em> parameter to move on based on time.)</p>
</dd></dl>

<dl class="method">
<dt id="mpf.system.light_controller.Playlist.stop">
<tt class="descname">stop</tt><big>(</big><em>reset=True</em><big>)</big></dt>
<dd><p>Stops a playlist. Pretty simple.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reset</strong> (<em>boolean</em>) &#8211; If <em>True</em>, it resets the playlist tracking</td>
</tr>
</tbody>
</table>
<p>counter back to the beginning. You can use <em>False</em> here if you want to
stop and then restart a playlist to pick up where it left off.</p>
</dd></dl>

</dd></dl>

</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/mpf.system.light_controller.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="index.html">Mission Pinball Framework 0.0.7 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Brian Madden, Gabe Knuth.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>